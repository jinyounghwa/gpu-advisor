# 안전장치 메커니즘

GPU Advisor 에이전트가 위험한 결정을 내리지 않도록 보호하는 다층 안전 시스템을 설명합니다.

## 안전장치 아키텍처

```
MCTS 정책 출력
    │
    ▼
[1층] 정책 보정 (Policy Calibration)
    │   MCTS + 보상 + 사전확률 + 효용편향 혼합
    ▼
[2층] 반붕괴 정규화 (Anti-Collapse Regularizer)
    │   최소 엔트로피 보장
    ▼
[3층] 신뢰도/엔트로피 게이트 (Confidence/Entropy Gate)
    │   불확실한 경우 → HOLD로 전환
    ▼
[4층] 릴리스 품질 게이트 (Release Quality Gates)
    │   전체 성능이 기준 미달이면 배포 차단
    ▼
최종 행동 출력
```

## 1층: 정책 보정 (Policy Calibration)

### 문제

MCTS만 사용하면 한 행동에 방문이 집중되어 **모드 붕괴(mode collapse)**가 발생할 수 있습니다.

### 해결

4개 신호를 가중 혼합하여 다양성을 보장합니다:

```python
calibrated = 0.45 × MCTS정책 + 0.25 × 보상정책 + 0.15 × 사전확률 + 0.15 × 효용편향
```

| 신호 | 가중치 | 역할 | 출처 |
|------|--------|------|------|
| MCTS 정책 | 0.45 | 계획 기반 핵심 결정 | `mcts_engine.search()` |
| 보상 정책 | 0.25 | 기대 보상 기반 보정 | `dynamics_network.forward()` |
| 사전 확률 | 0.15 | 학습 데이터 분포 반영 | 체크포인트 `action_prior` |
| 효용 편향 | 0.15 | 관찰 가능한 시장 신호 | 가격 추세, 이동평균 |

### 효용 편향 로직

```python
# 가격이 이동평균보다 높으면 → BUY_NOW 억제, WAIT 촉진
over_ma = max(현재가격 - 0.5 × (MA7 + MA14), -0.2)

# 상승 추세면 → 대기 촉진
trend_up = max(1일변화 + 0.5 × 7일변화, 0)

# 하락 추세면 → 매수 촉진
trend_down = max(-(1일변화 + 0.5 × 7일변화), 0)
```

이 "상식"은 모델이 시장 기본 원리를 무시하는 것을 방지합니다.

### 최소 확률 보장

```python
calibrated = np.maximum(calibrated, 0.02)  # 모든 행동이 최소 2% 확률
calibrated = calibrated / calibrated.sum()  # 정규화
```

**왜 2%인가?** 어떤 행동도 완전히 0%가 되면 안 됩니다. 2%는 결정적 샘플링에서도 모든 행동이 발생할 여지를 보장합니다.

## 2층: 반붕괴 정규화 (Anti-Collapse Regularizer)

### 문제

보정 후에도 엔트로피가 너무 낮으면(한 행동이 지배적이면) 에이전트가 다양한 시장 상황에 대응하지 못합니다.

### 해결

```python
min_entropy_target = 0.65  # 최소 엔트로피 목표
current_entropy = -Σ(p × log(p))

if current_entropy < min_entropy_target:
    # 사전확률 쪽으로 부드럽게 이동
    alpha = min(0.55, (목표 - 현재) / 목표)
    calibrated = (1 - alpha) × calibrated + alpha × prior_policy
```

| 엔트로피 값 | 의미 | 조치 |
|-------------|------|------|
| 0.0 | 한 행동만 100% (완전 붕괴) | 강한 정규화 |
| 0.65 | 최소 목표 | 정규화 시작 임계값 |
| 1.0 | 보통 다양성 | 정상 |
| 1.61 | 5개 행동 균등 분포 (최대) | 정상 |

### 왜 0.65인가?

- 5개 행동의 최대 엔트로피: ln(5) ≈ 1.609
- 0.65는 최대의 약 40% → 최소한 2~3개 행동이 의미 있는 확률을 가져야 함
- 너무 높으면 결정력이 떨어지고, 너무 낮으면 모드 붕괴

## 3층: 신뢰도/엔트로피 게이트

### 작동 방식

```python
if confidence < 0.25:       # 가장 높은 행동 확률이 25% 미만
    action = "HOLD"          # → 관망으로 전환
    safe_mode = True
    safe_reason = "low_confidence"

elif entropy > 1.58:         # 엔트로피가 최대의 98% 초과
    action = "HOLD"          # → 관망으로 전환
    safe_mode = True
    safe_reason = "high_entropy"
```

### 임계값 근거

**최소 신뢰도 = 0.25**

```
5개 행동 균등 확률: 1/5 = 0.20
최소 신뢰도:        0.25

0.25는 균등보다 25% 더 높은 확률을 요구합니다.
"최소한 이 행동이 다른 것보다 조금은 나아야 한다"
```

**최대 엔트로피 = 1.58**

```
최대 엔트로피 (균등): ln(5) = 1.609
임계값:              1.58 = 1.609 × 98%

엔트로피가 최대의 98% 이상이면, 사실상 모든 행동이 비슷한 확률 → 의미 있는 결정 불가
```

### 왜 HOLD로 전환하는가?

- **HOLD은 가장 안전한 행동**: 매수도 회피도 하지 않고 관망
- **정보 부족 시 최선**: 에이전트가 확신이 없으면 아무것도 하지 않는 것이 최선
- **알파고 비유**: 바둑에서도 형세가 불명확하면 안전한 수를 두는 것이 최선

## 4층: 릴리스 품질 게이트

에이전트 전체 성능을 백테스트로 평가하고, 기준 미달이면 배포를 차단합니다.

### 7가지 게이트

| 게이트 | 임계값 | 의미 |
|--------|--------|------|
| `accuracy_raw` | ≥ 0.55 | 방향 정확도가 55% 이상 (랜덤 50%보다 유의미) |
| `reward_raw` | > 0.0 | 평균 보상이 양수 (돈을 벌어야 함) |
| `abstain` | ≤ 0.85 | 관망 비율 85% 이하 (너무 소극적이면 안 됨) |
| `safe_override` | ≤ 0.90 | 안전장치 개입 90% 이하 (너무 자주 개입하면 에이전트 무의미) |
| `action_entropy_raw` | ≥ 0.25 | 행동 다양성 최소 보장 |
| `uplift_raw_vs_buy` | ≥ 0.0 | "항상 매수" 전략보다 나아야 함 |
| `no_mode_collapse_raw` | True | 한 행동이 95% 이상이면 실패 |

### 게이트 통과 로직

```python
# 모든 게이트를 통과해야 배포 승인
all_pass = all(gates.values())

if all_pass:
    status = "pass"       # 배포 후보
else:
    status = "blocked"    # 데이터/학습/정책 재조정 필요
```

### 기준선(Baseline) 비교

에이전트는 3가지 단순 전략보다 나아야 합니다:

```
1. "항상 매수" 전략: 매일 BUY_NOW → 시장 평균 수익
2. "항상 대기" 전략: 매일 WAIT_SHORT → 역시장 수익
3. "항상 관망" 전략: 매일 HOLD → 수수료 수준의 손실

에이전트 보상 > max(항상 매수, 항상 대기, 항상 관망) → 합격
```

## 안전장치 흐름도 예시

### 사례 1: 정상 동작

```
입력: RTX 5070
MCTS → 보정 → [BUY_NOW: 0.42, WAIT_SHORT: 0.28, ...]
신뢰도: 0.42 ≥ 0.25 ✓
엔트로피: 1.35 ≤ 1.58 ✓
→ 최종: BUY_NOW (원본 유지)
```

### 사례 2: 신뢰도 부족 → 안전 모드

```
입력: RTX 5090
MCTS → 보정 → [BUY_NOW: 0.22, WAIT_SHORT: 0.21, WAIT_LONG: 0.20, ...]
신뢰도: 0.22 < 0.25 ✗
→ 안전 모드 활성화
→ 최종: HOLD (강제 전환)
→ 이유: "low_confidence<0.25"
```

### 사례 3: 엔트로피 과다 → 안전 모드

```
입력: RX 7600
MCTS → 보정 → [0.205, 0.198, 0.202, 0.200, 0.195]
엔트로피: 1.609 > 1.58 ✗ (거의 균등 분포)
→ 안전 모드 활성화
→ 최종: HOLD (강제 전환)
→ 이유: "high_entropy>1.58"
```

## 학습 시 안전장치

학습 과정에서도 안전장치가 작동합니다:

| 메커니즘 | 위치 | 역할 |
|----------|------|------|
| 기울기 클리핑 | `fine_tuner.py` | 기울기 폭발 방지 (max_norm=1.0) |
| 엔트로피 보너스 | 손실 함수 | 정책 다양성 유지 (-0.001 × entropy) |
| 사전확률 정규화 | 손실 함수 | 데이터 분포 이탈 방지 (0.02 × KL) |
| 클래스 가중치 | `cross_entropy` | 불균형 행동 분포 보정 |

---

**관련 코드**:
- 추론 안전장치: `backend/agent/gpu_purchase_agent.py` — `decide_from_state()`
- 릴리스 게이트: `backend/agent/release_pipeline.py` — `quality_gates()`
- 학습 안전장치: `backend/agent/fine_tuner.py` — `_train_step()`
